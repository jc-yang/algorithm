## 高精度（c++涉及，Java和python不涉及，JavaScript可以使用BigInt）
一般涉及到四种运算（A、B表示大整数，a表示小整数）  
- A + B  
- A - B
- A * a
- A / a
大整数**位数**一般 <= 1e6，小整数的**数值**一般 <= 1e10
1. 大整数的存储  
大整数每一位存到数组，由个位到高位依次存入数组，因为进位后需要在数组后面添加元素
2. 

乘法：将被乘数看作整体去运算  
则结果的某位值 (A[i] * a) % 10，  
产生向前一位的进位为 (A[i] * a) / 10

除法：同样将被除数看作整体，由高位向低位运算（小学常规）  
产生的余数： 当前余数为 r = r * 10 + A[i]
产生的商：当前余数 r 除以 被除数, r / b  
下一位余数的高位： r % b

## 前缀和
原数列元素 a1, a2, a3, ... an  
前缀和 Si = a1 + a2 + a3 + ... + ai，下标从1开始
### 一维前缀和
#### 如何求前缀和Si
令 S[0] = 0
```
for (i = 1; i <= n; i++) {
 S[i] = S[i - 1] + ai
}
```
#### 前缀和Si的作用
可以快速求出原数组中一段元素的和  
如： [l,r] 区间的和，在O(n)复杂度下， 结果为 S[r] - S[l - 1]  
如： [1,10]：即 S[10] = S[10] - S[0]

### 二维前缀和
原数值 a[i,j]  
前缀和 S[i,j] 表示 所有 a[*,j] 到 a[i, *]的和，即左上角所有元素的和  
则 
```
for(i : 1 ~ n)
  for(j : 1 ~ m)
    S[i,j] = S[i-1,j] + S[i,j-1] - S[i-1,j-1] + a[i,j]
```
如图：   
![](https://github.com/jc-yang/algorithm/blob/main/assets/images/presum.png)

假设要求(x1,y1) 和 (x2,y2) 内的矩阵的和，  
则 `res = S[x2,y2] - S[x2,y1-1] - S[x1-1,y2] + S[x1-1,y1-1]`   
![](https://github.com/jc-yang/algorithm/blob/main/assets/images/presum1.png)

## 差分
### 差分概念
差分是前缀和的逆运算  
原数组 a1, a2, a3, a4  
构造 b 数组 b1, b2, b3, b4，  
使得 a 数组元素是b数组的前缀和，即 `ai = b1 + b2 + ... + bi`  
按照递推关系则有  
```
b1 = a1,   
b2 = a2 - a1,   
...   
bn = an - an-1  
```
求和即得前缀和，所以 b 就是 a 的差分，a 是 b 的前缀和

只要有 b 数组，就可以用 O(n) 的时间通过前缀和求出 a  
O(n): b -> a
### 使用差分
如题目：a 数组 [l,r] 区间内的元素都加上常数 c  
a[l]+c, a[l+1]+c, ... , a[r]+c  
则暴力做法为 O(n)，而差分做法可以做到 O(1):  
只需要给 b[l]+c即可，之后再通过前缀和求a[l]+c ~ a[r]+c  
根据前缀和，a[l]=b[1]+..+b[l], a[r]=b[1]+..+b[l]+..+b[r]，a[l]之后的所有元素都至少加上了b[l]，所以只需要给b[l]+c，就能够给每一个a[i]都+c  
同样，a[r]后面的元素也+c了，所以需要减去，故只需要b[r+1]-c即可

### 差分构造
我们只假定原数组a = [0,0,..,0]，则b = [0,0,..,0]，而题目给定的a若不是0，则可以看作是对a进行了n次的插入操作  
a[1] = 区间[1,1] + a[1], a[2] = 区间[2,2] + a[2]，所以差分是不需要专门构造，只有一个操作
```js
for(i: 1 ~ n) {
  insert(i, i, a[i]) // 构造差分b
}

function insert(l, r, c) {
  b[l] += c
  b[r+1] -= c
}
```