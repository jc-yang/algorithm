## 双指针算法
- 双指针维护两个区间
- 双指针维护同一个区间

双指针算法通常来说可用以下伪代码来表示
```
for(i = 0, j = 0; i < n; i++) {
  while(j < i && check(i,j)) {
    j++
    // 每道题目的具体逻辑
  }
}
```
### 双指针核心思想
```
for(i=0;i<n;i++){
  for(j=0;j<n;j++){
  }
}
```
双指针算法将上面的朴素算法两层嵌套的循环O(n方)优化到O(n)

## 最长连续不重复子序列的长度
i指针指示当前走到哪个字符，j指针指示当前子串的初始位置，i在后面，j在前面  
如果是数字组成的字符串，如1 2 2 3 5，可以用一个大的数组S[N]来存储当前位置的数字出现的次数
```
S[a[i]]++
S[a[j]]--
```
如果是字符串类型，则可以用对象存储当前字符出现的次数（如果是js的话，map的value需要初始化为0才能++运算）
```js
  if(S[a.charAt(i)] === undefined) {
    S[a.charAt(i)] = 0 // 初始化为0
  }
  S[a.charAt(i)]++
```

## 位运算
- 求n的二进制表示中的第k位数字： n >> k & 1  
先把第k位移到最后一位 n >> k，再看个位是几， x&1
- 返回n的最后一位1： lowbit(n) = n & -n  
```
-x = ~x + 1
所以
x & -x = x & (~x + 1)
```
- 最低位1变为0： n & (n - 1)
## 离散化——整数离散化
当所有数值的值域很大（如0~1e9），但个数有限（如1e5）时，我们希望把每个数值存储到数组中。  
通常存储，会将每个值存储到下标对应的数组中：[0,1,0,3,...,100,...,2000]。但若数值很大，就行不通了

因此，需要将每个数离散化映射到一个小的数组中：[1,3,100,2000,5000000]
### 离散化中的问题
